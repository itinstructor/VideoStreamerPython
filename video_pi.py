#!/usr/bin/env python3
"""
    Name: video_pi.py
    Author: 
    Created: 08/01/24
    Purpose: Stream video to a Tkinter interface using Picamera2
    Description: This script demonstrates how to display a live video stream
    and still images from the Raspberry Pi camera
    using the PiCamera2 library and Tkinter.
NOTE: Part of this program was generated by ChatGPT
"""

# Raspberry Pi Buster
# sudo pip3 install pillow -U

import tkinter as tk
import tkinter.ttk as ttk
# Import Picamera2 for controlling the camera
from picamera2 import Picamera2
# Import PIL for image processing
from PIL import Image, ImageTk
# Import datetime for timestamping the saved images
import datetime
# Import threading for running capture in a separate thread
import threading
# Import time for timing FPS calculation
import time


class PiCameraApp:
    def __init__(self):
        self.root = tk.Tk()

        # Set window location at
        # 600x50 for pi, 350x50 for pi zero
        self.root.geometry("+600+50")

        # Call self.quit when window is closed
        self.root.protocol("WM_DELETE_WINDOW", self.quit)

        self.root.title("Video Pi")

        # Initialize the Picamera2 object
        self.picam2 = Picamera2()

        # Create a preview configuration for the camera
        self.config = self.picam2.create_preview_configuration()

        # Configure the camera with the preview configuration
        self.picam2.configure(self.config)

        # A flag to control the streaming state, initially set to False
        self.is_streaming = False
        self.frame_count = 0  # Counter for the number of frames
        self.start_time = time.time()  # Start time for FPS calculation
        # Frame interval in milliseconds (for 30 FPS)
        self.frame_interval = 1000 / 30
        self.image = None  # Store the latest image

        # Initialize and start the capture thread
        self.capture_thread = threading.Thread(target=self._capture_frames)
        # Allow the thread to exit when the main program exits
        self.capture_thread.daemon = True
        self.capture_thread.start()

        self.create_widgets()
        self.root.mainloop()

# ---------------------- START VIDEO STREAM ------------------------------ #
    def start_stream(self):
        """
        Start the video stream.
        """
        self.is_streaming = True  # Set the streaming flag to True
        self.lbl_status_bar.configure(text=" Video Stream Running . . .")
        self.btn_start_stop.configure(text="Stop Stream")
        self.picam2.start()  # Start the camera

        self.update_image()  # Start updating the image

# ---------------------- STOP VIDEO STREAM ------------------------------- #
    def stop_stream(self):
        """
        Stop the video stream.
        """
        self.is_streaming = False  # Set the streaming flag to False
        self.btn_start_stop.configure(text="Start Stream")
        self.lbl_status_bar.configure(text=" Video Stream Stopped")
        self.picam2.stop()  # Stop the camera

# ---------------------- CAPTURE IMAGE ----------------------------------- #
    def capture_image(self):
        """
        Capture a still image in a separate thread, save it to the hard drive.
        """
        # Ensure that streaming is stopped before capturing an image
        if not self.is_streaming:
            threading.Thread(target=self._capture_image_thread).start()

# ---------------------- CAPTURE IMAGE THREAD ---------------------------- #
    def _capture_image_thread(self):
        """
        The actual method that captures the image
            and saves it to the hard drive.
        This is run in a separate thread to prevent blocking the main thread.
        """
        # Check again if streaming is stopped before capturing an image
        if not self.is_streaming:
            if self.image is not None:
                # Convert the frame array to an image
                image = Image.fromarray(self.image)

                # Convert image to RGB mode if necessary
                if image.mode == 'RGBA':
                    image = image.convert('RGB')

                # Generate a timestamped filename for the image
                filename = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S") + ".jpg"
                # Save the image to the hard drive in JPEG format
                image.save(filename, 'JPEG')
                print(f"Image saved as {filename}")

# ---------------------- CAPTURE FRAMES ---------------------------------- #
    def _capture_frames(self):
        """
        Continuously capture frames from the camera in a separate thread.
        """
        while True:
            if self.is_streaming:
                # Capture a frame from the camera
                frame = self.picam2.capture_array()
                # Store the latest frame
                self.image = frame
                # Sleep to maintain frame interval
                time.sleep(self.frame_interval / 1000.0)

# ---------------------- UPDATE IMAGE ------------------------------------ #
    def update_image(self):
        """
        Update the Label widget with the latest image from the camera.
        """
        # Check if there is a frame to display
        if self.image is not None:
            # Convert the frame array to an image that can be displayed in Tkinter
            image = Image.fromarray(self.image)
            image = ImageTk.PhotoImage(image)

            # Update the Label widget with the new image
            # self.label.config(image=image)
            # self.label.image = image
            # Create an image on the canvas at the specified coordinates
            self.canvas.create_image(
                0,            # x-coordinate for the image's top-left corner
                0,            # y-coordinate for the image's top-left corner
                # Anchor image at top-left corner (North-West)
                anchor=tk.NW,
                image=image   # Image to be displayed
            )

            # Store the image as an attribute of the object
            # to prevent garbage collection
            self.photo = image

            # Calculate FPS every second
            self.frame_count += 1
            current_time = time.time()
            elapsed_time = current_time - self.start_time
            if elapsed_time > 1.0:
                fps = self.frame_count / elapsed_time
                self.lbl_status_bar.config(text=f"FPS: {fps:.2f}")
                self.frame_count = 0
                self.start_time = current_time

        # Schedule the update_image method to be called again
        self.root.after(int(self.frame_interval), self.update_image)

# ----------------------- START STOP VIDEO STREAM ------------------------ #
    def start_stop_stream(self):
        """Stop or start the video stream"""
        if not self.is_streaming:
            self.start_stream()
        else:
            self.stop_stream()

# ------------------ CREATE WIDGETS ---------------------------------------#
    def create_widgets(self):
        """Create widgets"""
        # Constant to have all the buttons the same width
        BUTTON_WIDTH = 16

        # Create canvas to size and display image
        self.canvas = tk.Canvas(
            self.root,
            width=640,
            height=480
        )

        self.btn_start_stop = ttk.Button(
            self.root,
            text="Start Stream",
            command=self.start_stop_stream,
            width=BUTTON_WIDTH
        )

        self.btn_snapshot = ttk.Button(
            self.root,
            text="Capture Image",
            command=self.capture_image,
            width=BUTTON_WIDTH
        )

        self.btn_quit = ttk.Button(
            self.root,
            text="Quit",
            command=self.quit, width=BUTTON_WIDTH
        )

        message = f" Picamera2 Video Stream"
        self.lbl_status_bar = tk.Label(
            self.root, text=message, anchor=tk.W, relief=tk.RIDGE
        )

        self.canvas.grid(row=0, column=0, columnspan=4)

        self.btn_start_stop.grid(row=1, column=0)
        self.btn_snapshot.grid(row=1, column=2)
        self.btn_quit.grid(row=1, column=3)

        self.lbl_status_bar.grid(row=2, column=0, columnspan=4, sticky="WE")

        # Set padding for all widgets
        for child in self.root.winfo_children():
            child.grid_configure(padx=6, pady=6, ipadx=1, ipady=1)

        # The Escape key will activate the quit method
        self.root.bind('<Escape>', self.quit)

        # Handle window closing clean up cv2  camera resources
        self.root.protocol("WM_DELETE_WINDOW", quit)

# --------------------------- QUIT PROGRAM ------------------------------- #
    def quit(self, *args):
        """Close clean up picam2 resources, close the program"""
        self.picam2.stop()
        # self.stop_stream()
        self.root.destroy()


# Create an instance of the PiCameraApp class
app = PiCameraApp()
